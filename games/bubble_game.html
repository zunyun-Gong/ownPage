<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éƒ½æ˜¯æ³¡æ²« - 3D å°æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Microsoft YaHei', sans-serif;
            background: #1a1a2e;
        }
        
        #gameCanvas {
            display: block;
        }
        
        /* UI ç•Œé¢ */
        .ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* åˆ†æ•°æ˜¾ç¤º */
        .score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(255,105,180,0.9), rgba(255,20,147,0.9));
            padding: 15px 25px;
            border-radius: 15px;
            color: white;
            box-shadow: 0 5px 20px rgba(255,20,147,0.4);
        }
        
        .score-board h2 {
            font-size: 14px;
            margin-bottom: 5px;
            opacity: 0.9;
        }
        
        .score-board .score {
            font-size: 32px;
            font-weight: bold;
        }
        
        .score-board .coins {
            font-size: 18px;
            margin-top: 5px;
            color: #ffd700;
        }
        
        /* æ¼‚æµ®å¾—åˆ† */
        .floating-score {
            position: absolute;
            color: #ff69b4;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,105,180,0.8);
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px) scale(1.2);
            }
        }
        
        /* æ§åˆ¶è¯´æ˜ */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
        }
        
        .controls h3 {
            margin-bottom: 10px;
            color: #ff69b4;
        }
        
        .controls p {
            margin: 5px 0;
            opacity: 0.8;
        }
        
        .key {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 2px;
        }
        
        /* å¼€å§‹/ç»“æŸç”»é¢ */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: auto;
        }
        
        .overlay.hidden {
            display: none;
        }
        
        .overlay h1 {
            font-size: 56px;
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255,105,180,0.5);
        }
        
        .overlay p {
            color: #aaa;
            font-size: 18px;
            margin-bottom: 30px;
            text-align: center;
            max-width: 500px;
            line-height: 1.6;
        }
        
        .btn-start {
            padding: 15px 50px;
            font-size: 24px;
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(255,20,147,0.4);
        }
        
        .btn-start:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(255,20,147,0.6);
        }
        
        /* æ‰“å—æç¤º */
        .burp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255,215,0,0.8);
            animation: burpAnim 0.8s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes burpAnim {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -80%) scale(1);
            }
        }
    </style>
</head>
<body>
    <!-- UI å±‚ -->
    <div class="ui-container">
        <div class="score-board">
            <h2>ğŸº å•¤é…’æ”¶é›†</h2>
            <div class="score" id="score">0</div>
            <div class="coins">ğŸ’° é‡‘å¸: <span id="coins">0</span></div>
        </div>
        
        <div class="controls">
            <h3>ğŸ® æ“ä½œè¯´æ˜</h3>
            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> æˆ–æ–¹å‘é”®ç§»åŠ¨</p>
            <p>é è¿‘å•¤é…’æ¯è‡ªåŠ¨å–é…’</p>
            <p>æ”¶é›†æ³¡æ²«è·å¾—é‡‘å¸ï¼</p>
        </div>
    </div>
    
    <!-- å¼€å§‹ç”»é¢ -->
    <div class="overlay" id="startScreen">
        <h1>ğŸº éƒ½æ˜¯æ³¡æ²«</h1>
        <p>æ“æ§é»„è‰²å°äººæ”¶é›†ç²‰è‰²å•¤é…’<br>æ¯å–ä¸€æ¯è·å¾—é‡‘å¸ï¼Œå°å¿ƒä¸è¦å–é†‰å“¦ï¼<br>æ”¶é›†æ‰€æœ‰å•¤é…’æ¯è§£é”æ–°åœºæ™¯</p>
        <button class="btn-start" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            score: 0,
            coins: 0,
            isPlaying: false,
            beers: [],
            particles: []
        };
        
        // Three.js åœºæ™¯
        let scene, camera, renderer;
        let player, playerBody;
        let keys = {};
        let animationId;
        
        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 15);
            camera.lookAt(0, 0, 0);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            setupLights();
            
            // åˆ›å»ºåœ°é¢
            createGround();
            
            // åˆ›å»ºç©å®¶
            createPlayer();
            
            // åˆ›å»ºå•¤é…’æ¯
            createBeers();
            
            // åˆ›å»ºè£…é¥°
            createDecorations();
            
            // äº‹ä»¶ç›‘å¬
            setupEvents();
            
            // å¼€å§‹æ¸²æŸ“
            animate();
        }
        
        // è®¾ç½®ç¯å…‰
        function setupLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // ä¸»å…‰æº
            const dirLight = new THREE.DirectionalLight(0xffd700, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);
            
            // ç²‰è‰²æ°›å›´ç¯
            const pointLight = new THREE.PointLight(0xff69b4, 0.6, 20);
            pointLight.position.set(0, 5, 0);
            scene.add(pointLight);
        }
        
        // åˆ›å»ºåœ°é¢
        function createGround() {
            // ä¸»åœ°é¢
            const geometry = new THREE.PlaneGeometry(40, 40);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x2d2d44,
                transparent: true,
                opacity: 0.9
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // ç½‘æ ¼çº¿
            const gridHelper = new THREE.GridHelper(40, 20, 0xff69b4, 0x3d3d5c);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
            
            // è£…é¥°æ€§åœ°æ¿å›¾æ¡ˆ
            for (let i = 0; i < 8; i++) {
                const circleGeo = new THREE.CircleGeometry(1.5, 32);
                const circleMat = new THREE.MeshBasicMaterial({
                    color: 0xff69b4,
                    transparent: true,
                    opacity: 0.1
                });
                const circle = new THREE.Mesh(circleGeo, circleMat);
                circle.rotation.x = -Math.PI / 2;
                circle.position.set(
                    (Math.random() - 0.5) * 30,
                    0.02,
                    (Math.random() - 0.5) * 30
                );
                scene.add(circle);
            }
        }
        
        // åˆ›å»ºç©å®¶ï¼ˆé»„è‰²åœ†æ¶¦å°äººï¼‰
        function createPlayer() {
            player = new THREE.Group();
            
            // èº«ä½“ - é»„è‰²çƒä½“ï¼ˆåœ†æ¶¦å¯çˆ±ï¼‰
            const bodyGeo = new THREE.SphereGeometry(0.8, 32, 32);
            const bodyMat = new THREE.MeshPhongMaterial({
                color: 0xffd700,
                shininess: 100,
                specular: 0xffaa00
            });
            playerBody = new THREE.Mesh(bodyGeo, bodyMat);
            playerBody.castShadow = true;
            player.add(playerBody);
            
            // çœ¼ç›
            const eyeGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.25, 0.2, 0.65);
            player.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.25, 0.2, 0.65);
            player.add(rightEye);
            
            // è…®çº¢
            const cheekGeo = new THREE.CircleGeometry(0.15, 16);
            const cheekMat = new THREE.MeshBasicMaterial({
                color: 0xff9999,
                transparent: true,
                opacity: 0.6
            });
            
            const leftCheek = new THREE.Mesh(cheekGeo, cheekMat);
            leftCheek.position.set(-0.4, 0, 0.72);
            leftCheek.rotation.y = -0.3;
            player.add(leftCheek);
            
            const rightCheek = new THREE.Mesh(cheekGeo, cheekMat);
            rightCheek.position.set(0.4, 0, 0.72);
            rightCheek.rotation.y = 0.3;
            player.add(rightCheek);
            
            // åˆå§‹ä½ç½®
            player.position.set(0, 0.8, 0);
            scene.add(player);
        }
        
        // åˆ›å»ºå•¤é…’æ¯
        function createBeers() {
            const positions = [
                { x: 5, z: 5 },
                { x: -5, z: 5 },
                { x: 5, z: -5 },
                { x: -5, z: -5 },
                { x: 8, z: 0 },
                { x: -8, z: 0 },
                { x: 0, z: 8 },
                { x: 0, z: -8 },
                { x: 3, z: 3 },
                { x: -3, z: -3 }
            ];
            
            positions.forEach((pos, index) => {
                const beer = createBeerCup();
                beer.position.set(pos.x, 0.6, pos.z);
                beer.userData = { id: index, collected: false };
                scene.add(beer);
                gameState.beers.push(beer);
            });
        }
        
        // åˆ›å»ºå•ä¸ªå•¤é…’æ¯
        function createBeerCup() {
            const cupGroup = new THREE.Group();
            
            // æ¯èº« - ç²‰è‰²
            const cupGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.8, 16);
            const cupMat = new THREE.MeshPhongMaterial({
                color: 0xffc0cb,
                transparent: true,
                opacity: 0.9,
                shininess: 100
            });
            const cup = new THREE.Mesh(cupGeo, cupMat);
            cup.castShadow = true;
            cupGroup.add(cup);
            
            // æ¯å†…æ¶²ä½“
            const liquidGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.6, 16);
            const liquidMat = new THREE.MeshPhongMaterial({
                color: 0xff69b4,
                shininess: 120
            });
            const liquid = new THREE.Mesh(liquidGeo, liquidMat);
            liquid.position.y = 0.05;
            cupGroup.add(liquid);
            
            // æ³¡æ²«ç²’å­
            for (let i = 0; i < 8; i++) {
                const foamGeo = new THREE.SphereGeometry(0.08 + Math.random() * 0.05, 8, 8);
                const foamMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const foam = new THREE.Mesh(foamGeo, foamMat);
                foam.position.set(
                    (Math.random() - 0.5) * 0.4,
                    0.45 + Math.random() * 0.15,
                    (Math.random() - 0.5) * 0.4
                );
                foam.userData = {
                    originalY: foam.position.y,
                    speed: 0.02 + Math.random() * 0.02,
                    offset: Math.random() * Math.PI * 2
                };
                cupGroup.add(foam);
            }
            
            // é‡‘å¸ï¼ˆæ‚¬æµ®åœ¨æ¯å­ä¸Šæ–¹ï¼‰
            const coinGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16);
            const coinMat = new THREE.MeshPhongMaterial({
                color: 0xffd700,
                shininess: 200,
                metalness: 0.8
            });
            const coin = new THREE.Mesh(coinGeo, coinMat);
            coin.rotation.x = Math.PI / 2;
            coin.position.y = 1.2;
            coin.userData = { isCoin: true, rotationSpeed: 0.05 };
            cupGroup.add(coin);
            
            return cupGroup;
        }
        
        // åˆ›å»ºè£…é¥°
        function createDecorations() {
            // æ¼‚æµ®çš„æ³¡æ²«
            for (let i = 0; i < 20; i++) {
                const bubbleGeo = new THREE.SphereGeometry(0.1 + Math.random() * 0.2, 16, 16);
                const bubbleMat = new THREE.MeshPhongMaterial({
                    color: Math.random() > 0.5 ? 0xff69b4 : 0x87ceeb,
                    transparent: true,
                    opacity: 0.4,
                    shininess: 100
                });
                const bubble = new THREE.Mesh(bubbleGeo, bubbleMat);
                bubble.position.set(
                    (Math.random() - 0.5) * 35,
                    1 + Math.random() * 5,
                    (Math.random() - 0.5) * 35
                );
                bubble.userData = {
                    speedY: 0.01 + Math.random() * 0.02,
                    wobble: Math.random() * Math.PI * 2
                };
                scene.add(bubble);
                gameState.particles.push(bubble);
            }
        }
        
        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEvents() {
            // é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            gameState.isPlaying = true;
        }
        
        // æ›´æ–°ç©å®¶ä½ç½®
        function updatePlayer() {
            if (!gameState.isPlaying) return;
            
            const speed = 0.15;
            let moved = false;
            
            // WASD æˆ–æ–¹å‘é”®
            if (keys['w'] || keys['arrowup']) {
                player.position.z -= speed;
                moved = true;
            }
            if (keys['s'] || keys['arrowdown']) {
                player.position.z += speed;
                moved = true;
            }
            if (keys['a'] || keys['arrowleft']) {
                player.position.x -= speed;
                moved = true;
            }
            if (keys['d'] || keys['arrowright']) {
                player.position.x += speed;
                moved = true;
            }
            
            // é™åˆ¶ç§»åŠ¨èŒƒå›´
            player.position.x = Math.max(-18, Math.min(18, player.position.x));
            player.position.z = Math.max(-18, Math.min(18, player.position.z));
            
            // ç§»åŠ¨åŠ¨ç”»ï¼ˆè½»å¾®æ™ƒåŠ¨ï¼‰
            if (moved) {
                player.rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
                playerBody.scale.y = 1 + Math.sin(Date.now() * 0.02) * 0.05;
            } else {
                player.rotation.z *= 0.9;
                playerBody.scale.y += (1 - playerBody.scale.y) * 0.1;
            }
            
            // ç›¸æœºè·Ÿéš
            camera.position.x += (player.position.x - camera.position.x) * 0.1;
            camera.position.z = player.position.z + 15;
            camera.lookAt(player.position);
        }
        
        // æ£€æŸ¥ç¢°æ’
        function checkCollisions() {
            if (!gameState.isPlaying) return;
            
            gameState.beers.forEach((beer) => {
                if (beer.userData.collected) return;
                
                const distance = player.position.distanceTo(beer.position);
                
                if (distance < 1.5) {
                    // æ”¶é›†å•¤é…’
                    collectBeer(beer);
                }
            });
        }
        
        // æ”¶é›†å•¤é…’
        function collectBeer(beer) {
            beer.userData.collected = true;
            
            // æ›´æ–°åˆ†æ•°
            gameState.score++;
            gameState.coins += 1;
            updateUI();
            
            // æ˜¾ç¤ºæ¼‚æµ®å¾—åˆ†
            showFloatingScore(beer.position);
            
            // æ‰“å—æ•ˆæœ
            showBurp();
            
            // å–é…’åŠ¨ç”»ï¼ˆæ™ƒåŠ¨ï¼‰
            player.scale.set(1.3, 0.7, 1.3);
            setTimeout(() => {
                player.scale.set(1, 1, 1);
            }, 300);
            
            // æ¶ˆå¤±åŠ¨ç”»
            const fadeOut = setInterval(() => {
                beer.scale.multiplyScalar(0.9);
                beer.rotation.y += 0.2;
                if (beer.scale.x < 0.01) {
                    clearInterval(fadeOut);
                    scene.remove(beer);
                }
            }, 50);
        }
        
        // æ˜¾ç¤ºæ¼‚æµ®å¾—åˆ†
        function showFloatingScore(position) {
            const scoreEl = document.createElement('div');
            scoreEl.className = 'floating-score';
            scoreEl.textContent = '+1 ğŸº';
            
            // è½¬æ¢3Dåæ ‡åˆ°å±å¹•åæ ‡
            const vector = position.clone();
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            scoreEl.style.left = x + 'px';
            scoreEl.style.top = y + 'px';
            
            document.body.appendChild(scoreEl);
            
            setTimeout(() => scoreEl.remove(), 1000);
        }
        
        // æ˜¾ç¤ºæ‰“å—
        function showBurp() {
            const burps = ['å—~', 'å•Š~', 'å“ˆ~', 'å””~'];
            const burpEl = document.createElement('div');
            burpEl.className = 'burp-text';
            burpEl.textContent = burps[Math.floor(Math.random() * burps.length)];
            document.body.appendChild(burpEl);
            setTimeout(() => burpEl.remove(), 800);
        }
        
        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('coins').textContent = gameState.coins;
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // æ›´æ–°ç©å®¶
            updatePlayer();
            
            // æ£€æŸ¥ç¢°æ’
            checkCollisions();
            
            // åŠ¨ç”»å•¤é…’æ¯
            gameState.beers.forEach((beer) => {
                if (beer.userData.collected) return;
                
                // æ¯å­è½»å¾®æµ®åŠ¨
                beer.position.y = 0.6 + Math.sin(time + beer.userData.id) * 0.1;
                beer.rotation.y += 0.01;
                
                // æ³¡æ²«åŠ¨ç”»
                beer.children.forEach((child) => {
                    if (child.userData.speed) {
                        child.position.y = child.userData.originalY + 
                            Math.sin(time * 3 + child.userData.offset) * 0.05;
                    }
                    // é‡‘å¸æ—‹è½¬
                    if (child.userData.isCoin) {
                        child.rotation.y += child.userData.rotationSpeed;
                        child.position.y = 1.2 + Math.sin(time * 2) * 0.1;
                    }
                });
            });
            
            // åŠ¨ç”»æ¼‚æµ®æ³¡æ²«
            gameState.particles.forEach((bubble) => {
                bubble.position.y += bubble.userData.speedY;
                bubble.position.x += Math.sin(time + bubble.userData.wobble) * 0.01;
                
                if (bubble.position.y > 8) {
                    bubble.position.y = 0.5;
                    bubble.position.x = (Math.random() - 0.5) * 35;
                    bubble.position.z = (Math.random() - 0.5) * 35;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // å¯åŠ¨
        init();
    </script>
</body>
</html>
